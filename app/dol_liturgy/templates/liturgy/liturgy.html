{% extends "layout.html" %}

{% block title %}Liturgical Calendar{% endblock %}

{% block head_extensions %}
   
    <link rel="stylesheet" href="{{ url_for('liturgy_bp.static', filename='liturgy.css') }}">
     <script src='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.js'></script>
    
{% endblock %}

{% block content %}
    <div class="sticky-main-header d-flex justify-content-between align-items-center">
        <h5 class="mb-0">Liturgical Calendar</h5>
    </div>

    <div class="liturgy-page-content">
        <div id="calendar-container">
            <div id='calendar'></div>
        </div>
        <aside id="details-panel">
            <h4 id="details-title">Select a day</h4>
            <div id="details-content">
                <p>Click on a date to view its readings and prayers.</p>
            </div>
        </aside>
    </div>

<script>
    // This line is correct and does not need to change.
    const CALENDAR_DATA = {{ calendar_data | tojson }};
</script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        
        if (!CALENDAR_DATA || !document.getElementById('calendar')) {
            console.error("Calendar data or element not found.");
            return;
        }

        const calendarEl = document.getElementById('calendar');
        const detailsTitleEl = document.getElementById('details-title');
        const detailsContentEl = document.getElementById('details-content');

        // <!-- NEW: FLATTEN THE DATA STRUCTURE AT THE START -->
        // This is the key change. We convert the list-of-lists into a single flat list.
        // The .flat() method is modern JavaScript for exactly this purpose.
        const ALL_EVENTS = CALENDAR_DATA.litcal ? CALENDAR_DATA.litcal.flat() : [];

        async function fetchAndRenderDetails(dateStr, eventTitle) {
            detailsTitleEl.textContent = eventTitle || 'Loading...';
            detailsContentEl.innerHTML = '<p>Fetching today\'s readings...</p>';
            const apiUrl = `/liturgy/api/get-readings/${dateStr}`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) { throw new Error(`Our server failed with status ${response.status}`); }
                const data = await response.json();
                if (data.status === 'success' && data.readings) { 
                    renderReadings(data.readings, dateStr, eventTitle); 
                } else { 
                    throw new Error(data.message || 'Invalid data from our server.'); 
                }
            } catch (error) { 
                console.error('Error fetching day details from our backend:', error); 
                detailsTitleEl.textContent = 'Error'; 
                detailsContentEl.innerHTML = '<p>Could not retrieve the readings.</p>'; 
            }
        }

        function renderReadings(readings, dateStr, eventTitle) {
            detailsTitleEl.textContent = eventTitle;
            let contentHtml = '';
            if (readings.length > 0) { 
                readings.forEach(reading => { 
                    contentHtml += `<div class="reading-card"><h5 class="reading-title">${reading.title}</h5><div class="reading-body"><p>${reading.body.replace(/\n/g, '</p><p>')}</p></div></div>`; 
                });
            } else { 
                contentHtml += '<p>The readings for this day are not available.</p>'; 
            }
            detailsContentEl.innerHTML = contentHtml;
        }

         // --- CHANGE 1: Modify formatEvents to include original data for the tooltip ---
        function formatEvents(allEvents) {
            if (!allEvents) return [];
            return allEvents.filter(e => e.name).map(e => {
                const d = new Date(e.date * 1000);
                const colorMap = { "white": "#6c757d", "red": "#dc3545", "green": "#198754", "violet": "#6f42c1", "rose": "#d63384", "black": "#343a40" };
                let color = '#0d6efd';
                if (e.color && e.color.length > 0) { 
                    color = colorMap[e.color[0].toLowerCase()] || color; 
                }
                return { 
                    title: e.name, 
                    start: d.toISOString().split('T')[0], 
                    allDay: true, 
                    backgroundColor: color, 
                    borderColor: color,
                    // Pass the original event object in extendedProps
                    extendedProps: {
                        fullEvent: e
                    }
                };
            });
        }

        const calendar = new FullCalendar.Calendar(calendarEl, {
            themeSystem: 'bootstrap5',
            initialView: 'dayGridMonth',
            headerToolbar: { left: 'prev,next today', center: 'title', right: 'dayGridMonth,listYear' },
            eventDisplay: 'block', 
            height: 'auto',          
            dayMaxEvents: true,      
            events: formatEvents(ALL_EVENTS),
            
            // --- CHANGE 2: Add the eventDidMount callback to create tooltips ---
            eventDidMount: function(info) {
                const eventData = info.event.extendedProps.fullEvent;
                if (!eventData) return;

                // Build the HTML content for the tooltip
                const tooltipContent = `
                    <div class="liturgy-tooltip">
                        <p class="tooltip-title">${eventData.name}</p>
                        <p class="tooltip-detail"><strong>Grade:</strong> ${eventData.grade_lcl}</p>
                        <p class="tooltip-detail"><strong>Season:</strong> ${eventData.liturgical_season_lcl}</p>
                    </div>
                `;

                // Initialize a Bootstrap Tooltip on the event's DOM element
                new bootstrap.Tooltip(info.el, {
                    title: tooltipContent,
                    placement: 'top',
                    trigger: 'hover',
                    html: true, // This is crucial to allow HTML content
                    container: 'body' // Prevents tooltip from being trapped inside calendar elements
                });
            },

            dateClick: function(info) {
                // --- CHANGE: Search the flattened ALL_EVENTS array ---
                // We find the primary event (highest grade) for the clicked day.
                const eventsOnDay = ALL_EVENTS.filter(e => new Date(e.date * 1000).toISOString().split('T')[0] === info.dateStr);
                let title = `Readings for ${info.dateStr}`;
                if (eventsOnDay.length > 0) {
                    const primaryEvent = eventsOnDay.reduce((prev, current) => (prev.grade > current.grade) ? prev : current);
                    title = primaryEvent.name;
                }
                fetchAndRenderDetails(info.dateStr, title);
            },
            eventClick: function(info) {
                info.jsEvent.preventDefault(); 
                fetchAndRenderDetails(info.event.startStr, info.event.title);
            }
        });
        
        calendar.render();
    });
</script>
{% endblock %}